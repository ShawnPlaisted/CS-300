What was the problem you were solving in the projects for this course?

The projects focused on two main challenges: analyzing how different data structures perform and creating a program to manage and display course information. The goal was to understand how data structures handle tasks like searching, sorting, and storing data efficiently, while also building a functional program that could load, sort, and display courses in alphanumeric order.
How did you approach the problem?

To tackle these problems, I compared the performance of different data structures—vectors, hash tables, and binary search trees—based on their speed and memory usage. Choosing the right data structure is essential because it directly impacts how fast and efficiently data can be processed. For sorting and displaying the courses, I used a map because it keeps data automatically sorted, which simplified the process.
How did you overcome any roadblocks you encountered?

One of the biggest challenges I faced was dealing with unexpected input, like malformed data in the input file. To address this, I added error handling and made sure the program could handle different formats without crashing. I also broke the code into smaller, focused functions, which made debugging and testing much easier. Referring to documentation and testing edge cases also helped me get past these issues.
How has your work on this project expanded your approach to designing software and developing programs?

This project really highlighted the importance of picking the right tools for the job, like using a specific data structure based on the task’s needs. It also pushed me to think more about the long-term aspects of software design, like scalability and maintainability. I’ve started breaking down problems into smaller pieces and testing each part thoroughly, which has improved my overall approach to building programs.
How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

These projects helped me refine my coding habits, focusing on writing cleaner and more organized code. I’ve started using more descriptive variable names, structuring my programs with reusable functions, and adding error handling to make the code more robust. I’ve also learned to avoid hardcoding values, which makes my programs easier to update or expand later on. Overall, I feel more confident writing code that’s easy to read, maintain, and adapt.
